// Code generated by "ctenum create enum -package env -output lifecycle/lifecycle_ctenum.go lifecycle.yaml" version dev; DO NOT EDIT.

package env

import (
	"encoding"
	"errors"
	"fmt"
	"strconv"
	"strings"
)

// InvalidLifecycleEnumError is returned by [ToLifecycleEnum] if the passed in
// string isn't one of the enum values.
type InvalidLifecycleEnumError struct {
	s string
}

// Error exposes the invalid string used and shows all the possible values.
func (e InvalidLifecycleEnumError) Error() string {
	return strconv.Quote(e.s) + " does not belong to LifecycleEnum enum; " +
		"valid values are: " + strings.Join(LifecycleEnumStrings(), " ")
}

// Is tells you if target can be unwrapped to be an InvalidLifecycleEnumError.
func (e InvalidLifecycleEnumError) Is(err error) bool {
	return errors.As(err, &e)
}

// LifecycleEnum is a true enum, i.e. using this as a parameter in a function
// declaration requires the use of one of the constants defined in this package.
type LifecycleEnum interface {
	isLifecycleEnum()
	fmt.Stringer
	encoding.TextMarshaler
}

type _LifecycleEnum string

// isLifecycleEnum implements LifecycleEnum to make it a part of the compile-time
// safe enum.
func (_LifecycleEnum) isLifecycleEnum() {}

// String converts the private enum value to a primitive string.
func (x _LifecycleEnum) String() string {
	return string(x)
}

const (
	// LifecycleEnumSandBox Used for testing and development in an isolated environment.
	LifecycleEnumSandBox _LifecycleEnum = "sb"
	// LifecycleEnumNonProd Non-production environment for pre-production testing and validation.
	LifecycleEnumNonProd _LifecycleEnum = "np"
	// LifecycleEnumReleaseCandidate A candidate for release, typically the last testing stage before production.
	LifecycleEnumReleaseCandidate _LifecycleEnum = "rc"
	// LifecycleEnumProduction The live and operational environment where the application is accessible to users.
	LifecycleEnumProduction _LifecycleEnum = "pr"
)

var _LifecycleEnumMapping = map[string]_LifecycleEnum{
	"sb": LifecycleEnumSandBox,
	"np": LifecycleEnumNonProd,
	"rc": LifecycleEnumReleaseCandidate,
	"pr": LifecycleEnumProduction,
}

// ToLifecycleEnum retrieves an enum value from the constants defined in this
// package. It tries it's best to find s in the enum by using the original-case,
// uppercase and lowercase.
func ToLifecycleEnum(s string) (LifecycleEnum, error) {
	if val, ok := _LifecycleEnumMapping[s]; ok {
		return val, nil
	}
	if val, ok := _LifecycleEnumMapping[strings.ToLower(s)]; ok {
		return val, nil
	}
	if val, ok := _LifecycleEnumMapping[strings.ToUpper(s)]; ok {
		return val, nil
	}
	return nil, InvalidLifecycleEnumError{s: s}
}

// LifecycleEnumValues returns a slice of values of the LifecycleEnum enum.
// Each enum value matches the index of [LifecycleEnumStrings].
func LifecycleEnumValues() []LifecycleEnum {
	return []LifecycleEnum{
		LifecycleEnumSandBox,
		LifecycleEnumNonProd,
		LifecycleEnumReleaseCandidate,
		LifecycleEnumProduction,
	}
}

// LifecycleEnumStrings returns a slice of all enum values as strings. This could
// be useful for validation with something like [slices.Contains] or quickly
// seeing all values of an enum.
// Each string matches the index of [LifecycleEnumValues].
func LifecycleEnumStrings() []string {
	return []string{
		"sb",
		"np",
		"rc",
		"pr",
	}
}

// MarshalText implements the [encoding.TextMarshaler] for LifecycleEnum.
func (x _LifecycleEnum) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

type LifecycleEnumUnmarshaler string

func (x LifecycleEnumUnmarshaler) Extract() LifecycleEnum {
	if x == "" {
		return nil
	}
	v, err := ToLifecycleEnum(string(x))
	if err != nil {
		panic(fmt.Sprintf("Incorrect usage of %T!"+
			"Used for unmarshalling into the application", x))
	}
	return v
}

func (x *LifecycleEnumUnmarshaler) UnmarshalText(text []byte) error {
	v, err := ToLifecycleEnum(string(text))
	if err != nil {
		return err
	}
	*x = LifecycleEnumUnmarshaler(any(v).(_LifecycleEnum))
	return nil
}
