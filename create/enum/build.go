package enum

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"github.com/j-mnr/ctenum/enums"
	"gopkg.in/yaml.v3"
)

//go:generate go run github.com/j-mnr/ctenum create enum build.go
//ctenum:type=extension output=extension_ctenum.go
const (
	_yml  = ".yml"
	_yaml = ".yaml"
	_json = ".json"
	_go   = ".go"
)

//go:generate go run github.com/j-mnr/ctenum create enum build.go
//ctenum:type=flag output=flag_ctenum.go
const (
	// _type is the Go Type that will be used for the enum name.
	_type = "type"
	// output is the file relative to where ctenum was called.
	output = "output"
	// _package is the name of the package to put the enum into.
	_package = "package"
	// makeFile is a boolean that defaults to making a file named
	// <type>_ctenumer.go in the current relative directory.
	makeFile = "make-file"
)

var ErrTypeRequired = errors.New("a type name for the enum is required")

//go:embed file.tmpl
var fileTmpl string

type Enum struct {
	Package string
	Output  string
	Type    string
	Values  []ConstSpec
}

type ConstSpec struct {
	Comment string
	Name    string
	Value   string
}

func Build(version string, args []string, out, errW io.Writer) error {
	ffs := flag.NewFlagSet("create/enum flags", flag.ExitOnError)
	ffs.SetOutput(errW)
	ffs.Usage = func() {
		ffs.Output().Write([]byte("Usage of create enum:\n\tctenum create enum [flags] file\n"))
		ffs.PrintDefaults()
		os.Exit(1)
	}

	outputF := ffs.String(FlagEnumOutput.String(), "",
		"output file name; relative to where ctenum was executed")
	packageF := ffs.String(FlagEnumPackage.String(), "",
		"use to override the default package name")
	makeFileF := ffs.Bool(FlagEnumMakeFile.String(), false,
		"Create a srcdir/<XxxType>_ctenumer.go file instead of printing to stdout")
	if err := ffs.Parse(args); err != nil {
		fmt.Fprintln(errW, err)
		ffs.Usage()
	}
	if ffs.NArg() == 0 {
		ffs.Usage()
	}
	t, err := template.New("ctenum create enum@" + version).Funcs(template.FuncMap{
		"GeneratedCodeComment": generatedCodeComment(version,
			append([]string{"create", "enum"}, args...)),
		"DefaultValue":    defaultValue,
		"TitleCase":       titleCase,
		"FormEnumName":    formEnumName,
		"FormComment":     formComment,
		"PrivateEnum":     privateEnum,
		"FormatMapValues": formatMapValues,
	}).Parse(fileTmpl)
	if err != nil {
		return fmt.Errorf("create/enum: %w", err)
	}

	tmplEnum := setup(ffs.Args()[0])
	if *outputF != "" {
		tmplEnum.Output = *outputF
	}
	if *packageF != "" {
		tmplEnum.Package = *packageF
	}
	switch tmplEnum.Output {
	case "":
		if *makeFileF {
			tmplEnum.Output = filepath.Dir(tmplEnum.Output) + "/" +
				strings.ToLower(tmplEnum.Type) + "_ctenums.go"
		}
	default:
		if err := os.MkdirAll(filepath.Dir(tmplEnum.Output), os.ModePerm); err != nil {
			panic(err)
		}
	}
	if tmplEnum.Output != "" {
		f, err := os.Create(tmplEnum.Output)
		if err != nil {
			panic(err)
		}
		out = f
	}
	var buf bytes.Buffer
	if err := t.Execute(&buf, tmplEnum); err != nil {
		return fmt.Errorf("create/enum: %w", err)
	}

	b, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("create/enum: %w", err)
	}
	if _, err := out.Write(b); err != nil {
		return fmt.Errorf("create/enum: %w", err)
	}
	return nil
}

func generatedCodeComment(version string, args []string) func() string {
	return func() string {
		return `// Code generated by "ctenum ` +
			strings.Join(args, " ") + `" version ` + version + `; DO NOT EDIT.`
	}
}

func titleCase(s string) string {
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToUpper(r)) + s[n:]
}

func defaultValue(v ConstSpec) string {
	if v.Value == "" {
		v.Value = v.Name
	}
	return strconv.Quote(v.Value)
}

func formEnumName(typ, vname string) string {
	return typ + titleCase(vname)
}

func privateEnum(typ string) string {
	return "_" + typ
}

func formComment(ename, comment, vname string) string {
	if comment == "" {
		return ""
	}
	if !strings.HasSuffix(comment, ".") {
		comment += "."
	}
	comment = strings.TrimPrefix(strings.TrimLeft(comment, "_"), vname+" ")
	if !strings.HasPrefix(comment, "	"+ename) {
		comment = ename + " " + comment
	}
	var sb strings.Builder
	for _, line := range strings.Split(comment, "\n") {
		sb.WriteString("\n	// " + line)
	}
	return sb.String()
}

func formatMapValues(e Enum) string {
	longest := 0
	for _, v := range e.Values {
		if n := len(defaultValue(v)); n > longest {
			longest = n
		}
	}
	var sb strings.Builder
	for _, v := range e.Values {
		dv := defaultValue(v)
		sb.WriteString("\t" + dv + ":" +
			strings.Repeat(" ", 1+longest-len(dv)) +
			formEnumName(e.Type, v.Name) + ",\n")
	}
	return strings.TrimSuffix(sb.String(), "\n")
}

func setup(fileName string) Enum {
	raw, err := os.ReadFile(fileName)
	if err != nil {
		panic(err)
	}

	e := Enum{}
	ext, err := ToExtensionEnum(filepath.Ext(fileName))
	switch ext {
	case ExtensionEnumYAML, ExtensionEnumYml:
		if err := yaml.Unmarshal(raw, &e); err != nil {
			panic(err)
		}
	case ExtensionEnumJSON:
		if err := json.Unmarshal(raw, &e); err != nil {
			panic(err)
		}
	case ExtensionEnumGo:
		f, err := parser.ParseFile(token.NewFileSet(), fileName, nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		constBlock := f.Decls[slices.IndexFunc(f.Decls, func(d ast.Decl) bool {
			target, ok := d.(*ast.GenDecl)
			return ok && target.Tok == token.CONST && target.Doc != nil &&
				slices.ContainsFunc(target.Doc.List, func(c *ast.Comment) bool {
					if c == nil {
						return false
					}
					args, ok := strings.CutPrefix(c.Text, "//ctenum:")
					for _, a := range strings.Fields(args) {
						name, val, ok := strings.Cut(a, "=")
						if !ok {
							continue
						}
						flag, err := ToFlagEnum(name)
						if err != nil {
							continue
						}
						switch flag {
						case FlagEnumType:
							e.Type = val
						case FlagEnumOutput:
							e.Output = val
						case FlagEnumPackage:
							e.Package = val
						case FlagEnumMakeFile:
							e.Output = fileName[:strings.Index(fileName, filepath.Ext(fileName))] + "_ctenum.go"
						}
					}
					return ok
				})
		})]

		if e.Type == "" {
			base := filepath.Base(fileName)
			e.Type = base[:strings.Index(base, filepath.Ext(fileName))]
		}
		if e.Package == "" {
			e.Package = f.Name.Name
		}
		for _, spec := range constBlock.(*ast.GenDecl).Specs {
			v, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}
			e.Values = append(e.Values, ConstSpec{
				Comment: strings.TrimSpace(v.Doc.Text()),
				Name:    strings.TrimLeft(v.Names[0].Name, "_"),
				Value: func() string {
					s, err := strconv.Unquote(v.Values[0].(*ast.BasicLit).Value)
					if err != nil {
						panic(err)
					}
					return s
				}(),
			})
		}
	default:
		panic("Unsupported file type: " + strconv.Quote(filepath.Ext(fileName)))
	}
	e.Type = enums.FormatInitialism(titleCase(e.Type)) + "Enum"
	for i, v := range e.Values {
		e.Values[i].Name = enums.FormatInitialism(v.Name)
	}
	return e
}
