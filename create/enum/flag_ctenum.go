// Code generated by "ctenum create enum flag.go" version dev; DO NOT EDIT.

package enum

import (
	"encoding"
	"errors"
	"fmt"
	"strconv"
	"strings"
)

// InvalidFlagEnumError is returned by [ToFlagEnum] if the passed in
// string isn't one of the enum values.
type InvalidFlagEnumError struct {
	s string
}

// Error exposes the invalid string used and shows all the possible values.
func (e InvalidFlagEnumError) Error() string {
	return strconv.Quote(e.s) + " does not belong to FlagEnum enum; " +
		"valid values are: " + strings.Join(FlagEnumStrings(), " ")
}

// Is tells you if target can be unwrapped to be an InvalidFlagEnumError.
func (e InvalidFlagEnumError) Is(err error) bool {
	return errors.As(err, &e)
}

// FlagEnum is a true enum, i.e. using this as a parameter in a function
// declaration requires the use of one of the constants defined in this package.
type FlagEnum interface {
	isFlagEnum()
	fmt.Stringer
	encoding.TextMarshaler
}

type _FlagEnum string

// isFlagEnum implements FlagEnum to make it a part of the compile-time
// safe enum.
func (_FlagEnum) isFlagEnum() {}

// String converts the private enum value to a primitive string.
func (x _FlagEnum) String() string {
	return string(x)
}

const (
	// FlagEnumType is the Go Type that will be used for the enum name.
	FlagEnumType _FlagEnum = "type"
	// FlagEnumOutput is the file relative to where ctenum was called.
	FlagEnumOutput _FlagEnum = "output"
	// FlagEnumPackage is the name of the package to put the enum into.
	FlagEnumPackage _FlagEnum = "package"
	// FlagEnumMakeFile is a boolean that defaults to making a file named
	// <type>_ctenumer.go in the current relative directory.
	FlagEnumMakeFile _FlagEnum = "make-file"
)

var _FlagEnumMapping = map[string]_FlagEnum{
	"type":      FlagEnumType,
	"output":    FlagEnumOutput,
	"package":   FlagEnumPackage,
	"make-file": FlagEnumMakeFile,
}

// ToFlagEnum retrieves an enum value from the constants defined in this
// package. It tries it's best to find s in the enum by using the original-case,
// uppercase and lowercase.
func ToFlagEnum(s string) (FlagEnum, error) {
	if val, ok := _FlagEnumMapping[s]; ok {
		return val, nil
	}
	if val, ok := _FlagEnumMapping[strings.ToLower(s)]; ok {
		return val, nil
	}
	if val, ok := _FlagEnumMapping[strings.ToUpper(s)]; ok {
		return val, nil
	}
	return nil, InvalidFlagEnumError{s: s}
}

// FlagEnumValues returns a slice of values of the FlagEnum enum.
// Each enum value matches the index of [FlagEnumStrings].
func FlagEnumValues() []FlagEnum {
	return []FlagEnum{
		FlagEnumType,
		FlagEnumOutput,
		FlagEnumPackage,
		FlagEnumMakeFile,
	}
}

// FlagEnumStrings returns a slice of all enum values as strings. This could
// be useful for validation with something like [slices.Contains] or quickly
// seeing all values of an enum.
// Each string matches the index of [FlagEnumValues].
func FlagEnumStrings() []string {
	return []string{
		"type",
		"output",
		"package",
		"make-file",
	}
}

// MarshalText implements the [encoding.TextMarshaler] for FlagEnum.
func (x _FlagEnum) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

type FlagEnumUnmarshaler string

func (x FlagEnumUnmarshaler) Extract() FlagEnum {
	if x == "" {
		return nil
	}
	v, err := ToFlagEnum(string(x))
	if err != nil {
		panic(fmt.Sprintf("Incorrect usage of %T!"+
			"Used for unmarshalling into the application", x))
	}
	return v
}

func (x *FlagEnumUnmarshaler) UnmarshalText(text []byte) error {
	v, err := ToFlagEnum(string(text))
	if err != nil {
		return err
	}
	*x = FlagEnumUnmarshaler(any(v).(_FlagEnum))
	return nil
}
